// Lost Grid v4.2.0 - https://github.com/corysimmons/lost

@gutter: 30px;
@rtl: false;


/**
 * Sets a translucent background color to all elements it affects. Helpful while setting up, or debugging, the structure of your site to make sure all items are cleared correctly.
 *
 * @param {color} [@bg=blue] - A color to be lightened, so make sure you pick a darkish color.
 *
 * @example
 *   section {
 *     .edit(red);
 *   }
 */

.edit(@bg: blue) {
  * {
    background: fade(@bg, 10%);
  }
}


/**
 * Clearfix used to clear floated children blocks. http://nicolasgallagher.com/micro-clearfix-hack
 *
 * @example
 *   .parent {
 *     .cf();
 *     .child {
 *       .block(1 of 2);
 *     }
 *   }
 */

.cf() {
  *zoom: 1;
  &:before, &:after {
    content: '';
    display: table;
  }
  &:after {
    clear: both;
  }
}


/**
 * Horizontally center a container element and apply padding to it.
 *
 * @param {unit} [@max-size=980px] - A max-width to assign. Can be any unit.
 * @param {unit} [@pad=0] - Padding on the left and right of the element. Can be any unit.
 *
 * @example
 *   section {
 *     .center(900px);
 *   }
 */

.center(@max-size: 980px, @pad: 0) {
  .cf();
  max-width: @max-size;
  padding-left: @pad;
  padding-right: @pad;
  margin-left: auto;
  margin-right: auto;
}


/**
 * Vertically and/or horizontally align nested elements.
 *
 * @param {string} [@location=middle-center] - The position the nested element takes relative to the containing element.
 * @param {boolean} [@flex=false] - Whether align() will use Flexbox to perform centering or not. Options are false or flex (for readability).
 *
 * - reset
 * - top-left
 * - top-center or top
 * - top-right
 * - middle-left or left
 * - middle-right or right
 * - bottom-left
 * - bottom-center or bottom
 * - bottom-right
 *
 * @example
 *   .parent {
 *     .align();
 *     width: 600px;
 *     height: 400px;
 *     .child {
 *       width: 300px;
 *       height: 150px;
 *     }
 *   }
 */

.align(@location: middle-center, @flex: false) {
  & when (@flex = false) {
    position: relative;
    > * {
      position: absolute;
      top: 50%;
      right: auto;
      bottom: auto;
      left: 50%;
      transform: translate3d(-50%, -50%, 0);
      & when (@location = reset) {
        top: auto;
        right: auto;
        bottom: auto;
        left: auto;
        transform: translate3d(0, 0, 0);
      } & when (@location = top-left) {
        top: 0;
        right: auto;
        bottom: auto;
        left: 0;
        transform: translate3d(0, 0, 0);
      } & when (@location = top-center) {
        top: 0;
        right: auto;
        bottom: auto;
        left: 50%;
        transform: translate3d(-50%, 0, 0);
      } & when (@location = top) {
        top: 0;
        right: auto;
        bottom: auto;
        left: 50%;
        transform: translate3d(-50%, 0, 0);
      } & when (@location = top-right) {
        top: 0;
        right: 0;
        bottom: auto;
        left: auto;
        transform: translate3d(0, 0, 0);
      } & when (@location = middle-left) {
        top: 50%;
        right: auto;
        bottom: auto;
        left: 0;
        transform: translate3d(0, -50%, 0);
      } & when (@location = left) {
        top: 50%;
        right: auto;
        bottom: auto;
        left: 0;
        transform: translate3d(0, -50%, 0);
      } & when (@location = middle-right) {
        top: 50%;
        right: 0;
        bottom: auto;
        left: auto;
        transform: translate3d(0, -50%, 0);
      } & when (@location = right) {
        top: 50%;
        right: 0;
        bottom: auto;
        left: auto;
        transform: translate3d(0, -50%, 0);
      } & when (@location = bottom-left) {
        top: auto;
        right: auto;
        bottom: 0;
        left: 0;
        transform: translate3d(0, 0, 0);
      } & when (@location = bottom-center) {
        top: auto;
        right: auto;
        bottom: 0;
        left: 50%;
        transform: translate3d(-50%, 0, 0);
      } & when (@location = bottom) {
        top: auto;
        right: auto;
        bottom: 0;
        left: 50%;
        transform: translate3d(-50%, 0, 0);
      } & when (@location = bottom-right) {
        top: auto;
        right: 0;
        bottom: 0;
        left: auto;
        transform: translate3d(0, 0, 0);
      }
    }
  }
  & when (@flex = flex) {
    display: flex;
    justify-content: center;
    align-items: center;
    & when (@location = reset) {
      justify-content: inherit;
      align-items: inherit;
    } & when (@location = top-left) {
      justify-content: flex-start;
      align-items: flex-start;
    } & when (@location = top-center) {
      justify-content: center;
      align-items: flex-start;
    } & when (@location = center) {
      justify-content: center;
      align-items: flex-start;
    } & when (@location = top-right) {
      justify-content: flex-end;
      align-items: flex-start;
    } & when (@location = middle-left) {
      justify-content: flex-start;
      align-items: center;
    } & when (@location = left) {
      justify-content: flex-start;
      align-items: center;
    } & when (@location = middle-right) {
      justify-content: flex-end;
      align-items: center;
    } & when (@location = right) {
      justify-content: flex-end;
      align-items: center;
    } & when (@location = bottom-left) {
      justify-content: flex-start;
      align-items: flex-end;
    } & when (@location = bottom-center) {
      justify-content: center;
      align-items: flex-end;
    } & when (@location = center) {
      justify-content: center;
      align-items: flex-end;
    } & when (@location = bottom-right) {
      justify-content: flex-end;
      align-items: flex-end;
    }
  }
}


/**
 * Creates a block that is a fraction of the size of it's containing element with a gutter. Think of this like a column except it can go vertical as well by setting @dir to 'column' or 'both'. You don't need to pass any additional ratios (fractions) as the grid system will make use of calc(). Note that fractions must always be wrapped in quotes.
 *
 * @param {string} [@fraction=1 of 1] - This is a simple fraction of the containing element's width or height depending on @dir. This must be a string written X of Y.
 * @param {string} [@dir=row] - The direction of the grid. Can be row (horizontal grid), column (vertical grid), or both (waffle grid).
 * @param {number} [@cycle=extract(@fraction, 3)] - Lost works by assigning a margin-right to all elements except the last in the row. It does this by default by using the denominator of the fraction you pick. To override this default use this param. e.g. block('2/4', @cycle: 2)
 * @param {number} [@gut=@gutter] - The margin on the side of the element used to create a gutter. Typically this is left alone and the global @gutter will be used, but you can override it here if you want certain elements to have a particularly large or small gutter (pass 0 for no gutter at all).
 * @param {boolean} [@masonry-friendly=false] - Dictates whether this particular group of elements will work well with JS masonry plugins. This will assign a margin on each side of the element and you will need to wrap this group of elements in a masonry-row().
 *
 * @example
 *   figure {
 *     .block(1 of 3);
 *   }
 */

.block(@fraction: 1 of 1, @dir: row, @cycle: extract(@fraction, 3), @gut: @gutter, @masonry-friendly: false) {

  @numerator: extract(@fraction, 1);
  @denominator: extract(@fraction, 3);
  @_fraction: e('@{numerator}/@{denominator}');

  & when (@dir = row) {
    & when (@masonry-friendly) {
      margin-left: (@gut / 2);
      margin-right: (@gut / 2);
      &:nth-child(@{cycle}n) {
        clear: none;
      }
      &:nth-child(@{cycle}n + 1) {
        & when (@rtl = true) {
          clear: right;
        }
        & when not (@rtl = true) {
          clear: left;
        }
      }
      & when (@gut = 0) {
        width: e(%('calc(99.999999% * %s)', @_fraction));
      }
      & when not (@gut = 0) {
        width: e(%('calc(99.99% * %s - %s)', @_fraction, @gut));
      }
    }
    & when not (@masonry-friendly = true) {
      & when (@rtl = true) {
        margin-left: @gut;
      }
      & when not (@rtl = true) {
        margin-right: @gut;
      }
      & when (@gut = 0) {
        width: e(%('calc(99.999999% * %s)', @_fraction));
      }
      & when not (@gut = 0) {
        & when (@masonry-friendly = true) {
          width: e(%('calc(99.99% * %s - %s)', @_fraction, @gut));
        }
        & when not (@masonry-friendly = true) {
          width: e(%('calc(99.99% * %s - (%s - %s * %s))', @_fraction, @gut, @gut, @_fraction));
        }
      }
      & when (@rtl = true) {
        &:nth-child(n) {
          margin-left: @gut;
          float: right;
          clear: none;
        }
        &:last-child {
          margin-left: 0;
        }
        &:nth-child(@{cycle}n) {
          margin-left: 0;
          float: left;
        }
        &:nth-child(@{cycle}n + 1) {
          clear: right;
        }
      }
      & when not (@rtl = true) {
        &:nth-child(n) {
          margin-right: @gut;
          float: left;
          clear: none;
        }
        &:last-child {
          margin-right: 0;
        }
        &:nth-child(@{cycle}n) {
          margin-right: 0;
          float: right;
        }
        &:nth-child(@{cycle}n + 1) {
          clear: left;
        }
      }
    }
  }

  & when (@dir = column) {
    & when (@gut = 0) {
      height: e(%('calc(99.999999% * %s)', @_fraction));
    }
    & when not (@gut = 0) {
      & when (@masonry-friendly = true) {
        height: e(%('calc(99.99% * %s - %s)', @_fraction, @gut));
      }
      & when not (@masonry-friendly = true) {
        height: e(%('calc(99.99% * %s - (%s - %s * %s))', @_fraction, @gut, @gut, @_fraction));
      }
    }
    margin-bottom: @gut;
    &:last-child {
      margin-bottom: 0;
    }
  }

  & when (@dir = both) {
    float: left;
    margin-right: @gut;
    & when (@gut = 0) {
      width: e(%('calc(99.999999% * %s)', @_fraction));
      height: e(%('calc(99.999999% * %s)', @_fraction));
    }
    & when not (@gut = 0) {
      & when (@masonry-friendly = true) {
        width: e(%('calc(99.99% * %s - %s)', @_fraction, @gut));
        height: e(%('calc(99.99% * %s - %s)', @_fraction, @gut));
      }
      & when not (@masonry-friendly = true) {
        width: e(%('calc(99.99% * %s - (%s - %s * %s))', @_fraction, @gut, @gut, @_fraction));
        height: e(%('calc(99.99% * %s - (%s - %s * %s))', @_fraction, @gut, @gut, @_fraction));
      }
    }
    & when (@rtl = true) {
      &:nth-child(n) {
        margin-left: @gut;
        clear: none;
      }
      &:nth-child(@{cycle}n), &:last-child {
        margin-left: 0;
      }
      &:nth-child(@{cycle}n + 1) {
        clear: right;
      }
    }
    & when not (@rtl = true) {
      &:nth-child(n) {
        margin-right: @gut;
        clear: none;
      }
      &:nth-child(@{cycle}n), &:last-child {
        margin-right: 0;
      }
      &:nth-child(@{cycle}n + 1) {
        clear: left;
      }
    }
    margin-bottom: @gut;
    &:last-child {
      margin-bottom: 0;
    }
    &:nth-last-child(-n + @{cycle}) {
      margin-bottom: 0;
    }
  }
}


/**
 * Margin to the left, right, bottom, or top, of an element depending on if the fraction passed is positive or negative. It works for both horizontal and vertical grids but not both.
 *
 * @param {string} [@fraction=1 of 1] - Fraction of the container to be offset. Must be a string written as X of Y.
 * @param {string} [@dir=row] - Direction the grid is going. Should match the block() it's being used on.
 * @param {number} [@gut=@gutter] - How large the gutter involved is, typically this won't be adjusted, but if you have set the blocks for that row to have different gutters than default, you will need to match that gutter here as well.
 *
 * @example
 *   .two-elements {
 *     .block(1 of 3);
 *     &:first-child {
 *       .offset(1 of 3);
 *     }
 *   }
 */

.offset(@fraction: 1 of 1, @dir: row, @gut: @gutter) {
  @numerator: extract(@fraction, 1);
  @denominator: extract(@fraction, 3);
  @_fraction: e('@{numerator}/@{denominator}');
  & when (@dir = row) {
    & when (@numerator > 0) {
      & when (@gut = 0) {
        margin-right: e(%('calc(99.999999% * %s)', @_fraction)) !important;
      }
      & when not (@gut = 0) {
        margin-right: e(%('calc(99.99% * %s - (%s - %s * %s) + (%s * 2))', @_fraction, @gut, @gut, @_fraction, @gut)) !important;
      }
    }
    & when (@numerator < 0) {
      & when (@gut = 0) {
        margin-left: e(%('calc(99.999999% * (%s * -1))', @_fraction)) !important;
      }
      & when (@numerator > 0) {
        margin-left: e(%('calc(99.99% * (%s * -1) - (%s - %s * (%s * -1)) + %s)', @_fraction, @gut, @gut, @_fraction, @gut)) !important;
      }
    }
    & when (@numerator = 0) {
      margin-left: 0 !important;
      margin-right: @gut !important;
    }
  }
  & when (@dir = column) {
    & when (@numerator > 0) {
      & when (@gut = 0) {
        margin-bottom: e(%('calc(99.999999% * %s)', @_fraction)) !important;
      }
      & when not (@gut = 0) {
        margin-bottom: e(%('calc(99.99% * %s - (%s - %s * %s) + (%s * 2))', @_fraction, @gut, @gut, @_fraction, @gut)) !important;
      }
    }
    & when (@numerator < 0) {
      & when (@gut = 0) {
        margin-top: e(%('calc(99.999999% * (%s * -1))', @_fraction)) !important;
      }
      & when not (@gut = 0) {
        margin-top: e(%('calc(99.99% * (%s * -1) - (%s - %s * (%s * -1)) + (%s * 2))', @_fraction, @gut, @gut, @_fraction, @gut)) !important;
      }
    }
    & when (@numerator = 0) {
      margin-top: 0 !important;
      margin-bottom: @gut !important;
    }
  }
}


/**
 * Source ordering. Shift elements left, right, up, or down, by their left or top position by passing a positive or negative fraction.
 *
 * @param {string} [@fraction=1 of 1] - Fraction of the container to be shifted. Must be a string written as X of Y.
 * @param {string} [@dir=row] - Direction the grid is going. Should match the block() it's being used on.
 * @param {number} [@gut=@gutter] - Adjust the size of the gutter for this movement. Should match the block's @gut.
 *
 * @example
 *   figure {
 *     .block(1 of 2);
 *     &:first-child {
 *       .move(1 of 2);
 *     }
 *     &:last-child {
 *       .move(-1 of 2);
 *     }
 *   }
 */

.move(@fraction: 1 of 1, @dir: row, @gut: @gutter) {
  @numerator: extract(@fraction, 1);
  @denominator: extract(@fraction, 3);
  @_fraction: e('@{numerator}/@{denominator}');
  position: relative;
  & when (@dir = row) {
    left: e(%('calc(99.99% * %s - (%s - %s * %s) + %s)', @_fraction, @gut, @gut, @_fraction, @gut));
    & when (@gut = 0) {
      left: e(%('calc(99.999999% * %s)', @_fraction));
    }
  }
  & when (@dir = column) {
    top: e(%('calc(99.99% * %s - (%s - %s * %s) + %s)', @_fraction, @gut, @gut, @_fraction, @gut));
    & when (@gut = 0) {
      top: e(%('calc(99.999999% * %s)', @_fraction));
    }
  }
}


/**
 * Creates a row element for working with JS masonry libraries like Isotope. Assigns a negative margin on each side of this wrapping element.
 *
 * @param {number} [@gut=@gutter] - How large the gutter involved is, typically this won't be adjusted and will inherit the global @gutter setting, but it's made available if you want your masonry grid to have a special @gut, it should match your blocks' @guts.
 *
 * @example
 *   section {
 *     .masonry-row();
 *   }
 *   figure {
 *     .block(1 of 3, @masonry-friendly: true);
 *   }
 */

.masonry-row(@gut: @gutter) {
  .cf();
  margin-left: -(@gut / 2);
  margin-right: -(@gut / 2);
}
